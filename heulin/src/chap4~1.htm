<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.03 [fr] (Win95; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EF" VLINK="#55188A" ALINK="#FF0000">

<CENTER><B><FONT COLOR="#000000"><FONT SIZE=+3>Mise en pratique</FONT></FONT></B></CENTER>
&nbsp;

<P><FONT SIZE=+1>Maintenant que nous disposons d'un bon nombre d'&eacute;l&eacute;ments
math&eacute;matiques n&eacute;cessaires &agrave; la synth&egrave;se d'image
3D, il est temps de passer &agrave; une application concr&egrave;te. Pour
cela, nous allons reprendre le cube de notre premier exemple, et lui appliquer
les transformations g&eacute;om&eacute;triques que nous venons de d&eacute;couvrir
au chapitre pr&eacute;c&eacute;dent.</FONT>

<P><B><U><FONT SIZE=+2>1/ Les outils graphiques n&eacute;cessaires</FONT></U></B>

<P><FONT SIZE=+1>Toutes les s&eacute;quences de code pr&eacute;sent&eacute;es
sont enti&egrave;rement portables, si ce n'est les primitives graphiques
(initialisation du mode graphique, affichage d'un pixel...). Aussi, afin
de pousser encore un peu plus la portabilit&eacute; de mes programmes,
je vais utiliser un &eacute;cran virtuel dans lequel on dessinera la sc&egrave;ne
&agrave; afficher. Ainsi, la seule fonction non portable est celle qui
effectue le transfert de cette zone m&eacute;moire vers la zone d'&eacute;cran.
Il est donc relativement simple d'adapter les programmes &agrave; n'importe
quel type de machine.</FONT>

<P><FONT SIZE=+1>A titre d'illustration, l'ensemble de ces primitives a
&eacute;t&eacute; regroup&eacute; dans un fichier s&eacute;par&eacute;,
<A HREF="graphics.c">graphics.c.</A> A ce niveau, il n'est pas n&eacute;cessaire
de se soucier de la mani&egrave;re dont cela est g&eacute;r&eacute;, m&ecirc;me
si c'est relativement simple. Par la suite, dans un soucis d'optimisation,
il faudra pouvoir acc&eacute;der directement &agrave; l'&eacute;cran virtuel
sans passer par des primitives.</FONT>

<P><B><U><FONT SIZE=+2>2/ Animation des sommets d'un cube</FONT></U></B>

<P><FONT SIZE=+1>Comme la plus grande majorit&eacute; des d&eacute;butants
en 3D, nous allons commencer par animer les sommets d'un cube. Partant
de cela, il est possible d'animer n'importe quel type d'objet. Il y aura
cependant de nouveaux &eacute;l&eacute;ments &agrave; acqu&eacute;rir pour
pouvoir afficher correctement des objets aux faces pleines, chose que nous
verrons dans un chapitre suivant. Les sources compl&egrave;tes sont disponibles
dans <A HREF="cube2.zip">cube2.zip</A>.</FONT>

<P><FONT SIZE=+1>Une des &eacute;tapes essentielles &agrave; l'animation
est la rotation des sommets. Maintenant que nous savons comment cela fonctionne,
nous allons &eacute;crire une fonction.</FONT>
<PRE><FONT SIZE=+1>void Rotation(int Xa, int Ya, int Za)
{&nbsp;
&nbsp; int i;</FONT></PRE>

<PRE><FONT SIZE=+1>&nbsp; /* Calcul de la matrice de rotation 3*3 */</FONT></PRE>

<PRE><FONT SIZE=+1>&nbsp; matrice[0][0] = Cos[Za]*Cos[Ya];&nbsp;
&nbsp; matrice[1][0] = Sin[Za]*Cos[Ya];&nbsp;
&nbsp; matrice[2][0] = -Sin[Ya];</FONT></PRE>

<PRE><FONT SIZE=+1>&nbsp; matrice[0][1] = Cos[Za]*Sin[Ya]*Sin[Xa] - Sin[Za]*Cos[Xa];&nbsp;
&nbsp; matrice[1][1] = Sin[Za]*Sin[Ya]*Sin[Xa] + Cos[Xa]*Cos[Za];&nbsp;
&nbsp; matrice[2][1] = Sin[Xa]*Cos[Ya];</FONT></PRE>

<PRE><FONT SIZE=+1>&nbsp; matrice[0][2] = Cos[Za]*Sin[Ya]*Cos[Xa] + Sin[Za]*Sin[Xa];&nbsp;
&nbsp; matrice[1][2] = Sin[Za]*Sin[Ya]*Cos[Xa] - Cos[Za]*Sin[Xa];&nbsp;
&nbsp; matrice[2][2] = Cos[Xa]*Cos[Ya];</FONT></PRE>

<PRE><FONT SIZE=+1>&nbsp; /* Rotation des sommets de l'objet */
&nbsp; for(i=0;i&lt;Nb_points;i++)&nbsp;
&nbsp;&nbsp;&nbsp; {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point3D[i].x = matrice[0][0]*Sommet[i].x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrice[1][0]*Sommet[i].y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrice[2][0]*Sommet[i].z;</FONT></PRE>

<PRE><FONT SIZE=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point3D[i].y = matrice[0][1]*Sommet[i].x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrice[1][1]*Sommet[i].y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrice[2][1]*Sommet[i].z;</FONT></PRE>

<PRE><FONT SIZE=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point3D[i].z = matrice[0][2]*Sommet[i].x +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrice[1][2]*Sommet[i].y +&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; matrice[2][2]*Sommet[i].z; }</FONT></PRE>

<PRE><FONT SIZE=+1>&nbsp;&nbsp; }
}</FONT></PRE>
<FONT SIZE=+1>Comme vous pouvez le constater, nous calculons au pr&eacute;alable
la matrice de rotation, et ensuite nous transformons chaque sommet. Si
l'on ne tient pas compte de l'&eacute;tape de calcul de la matrice , cela
nous fera ensuite 9 multiplications par sommets. Si on n'utilisait pas
de matrice, nous aurions 12 multiplications par sommet. Sachant qu'un objet
3D peut contenir plusieurs milliers, voire dizaines de milliers de sommets,
le gain n'est pas si n&eacute;gligeable que cela.</FONT>

<P><FONT SIZE=+1>Il est possible d'am&eacute;liorer encore cette rotation.
Une m&eacute;thode bien connue de tous aujourd'hui permet de descendre
&agrave; 6 multiplications par sommets. Pour arriver &agrave; ce r&eacute;sultat
il suffit de factoriser de fa&ccedil;on judicieuse. Je ne vais pas vous
faire de d&eacute;monstration, je vous donne simplement la fonction correspondante.
A titre d'indication, je n'ai pas not&eacute; de gain notable sur ma machine,
mais les fous d'optimisation y trouveront leur compte. Sachez aussi que
l'on peut encore r&eacute;duire le nombre de multiplications.</FONT>
<PRE><FONT SIZE=+1>void Rotation6Mul(int Xa, int Ya, int Za)
{
&nbsp; int i;
&nbsp; float a[3];

&nbsp; matrice[0][0] = Cos[Za]*Cos[Ya];
&nbsp; matrice[1][0] = Sin[Za]*Cos[Ya];
&nbsp; matrice[2][0] = -Sin[Ya];

&nbsp; matrice[0][1] = Cos[Za]*Sin[Ya]*Sin[Xa] - Sin[Za]*Cos[Xa];
&nbsp; matrice[1][1] = Sin[Za]*Sin[Ya]*Sin[Xa] + Cos[Xa]*Cos[Za];
&nbsp; matrice[2][1] = Sin[Xa]*Cos[Ya];

&nbsp; matrice[0][2] = Cos[Za]*Sin[Ya]*Cos[Xa] + Sin[Za]*Sin[Xa];
&nbsp; matrice[1][2] = Sin[Za]*Sin[Ya]*Cos[Xa] - Cos[Za]*Sin[Xa];
&nbsp; matrice[2][2] = Cos[Xa]*Cos[Ya];

&nbsp; a[0]=-(matrice[0][1]*matrice[0][0]);
&nbsp; a[1]=-(matrice[1][1]*matrice[1][0]);
&nbsp; a[2]=-(matrice[2][1]*matrice[2][0]);

&nbsp; for(i=0;i&lt;Nb_points;i++)
&nbsp; {
&nbsp;&nbsp;&nbsp; Point3D[i].x =&nbsp;&nbsp; (matrice[0][1]+Sommet[i].x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (matrice[0][0]+Sommet[i].y)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + a[0] + Sommet[i].xy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + matrice[0][2]*Sommet[i].z;

&nbsp;&nbsp;&nbsp; Point3D[i].y =&nbsp;&nbsp; (matrice[1][1]+Sommet[i].x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (matrice[1][0]+Sommet[i].y)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + a[1] + Sommet[i].xy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + matrice[1][2]*Sommet[i].z;

&nbsp;&nbsp;&nbsp; Point3D[i].z =&nbsp;&nbsp; (matrice[2][1]+Sommet[i].x)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * (matrice[2][0]+Sommet[i].y)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + a[2] + Sommet[i].xy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + matrice[2][2]*Sommet[i].z;
&nbsp; }&nbsp;
}</FONT></PRE>
<FONT SIZE=+1>Il faut ajouter un nouveau champ &agrave; chaque sommet,
appel&eacute; ici Sommet[i].xy. Cette valeur doit &ecirc;tre initialis&eacute;e
au d&eacute;but du programme et n'a pas besoin d'&ecirc;tre recalcul&eacute;e
par la suite.</FONT>
<CENTER><PRE><B><FONT SIZE=+1>Sommet[i].xy = - Sommet[i].x*Sommet[i].y;</FONT></B></PRE></CENTER>
<FONT SIZE=+1>Apr&egrave;s avoir fait la rotation de chacun des sommets
de notre joli petit cube, il nous faut encore les projeter sur notre &eacute;cran.
Pour simplifier le code (et l'optimiser un tout petit peu), nous allons
placer l'observateur dans l'axe exact de l'objet (face au centre de l'&eacute;cran).</FONT>
<PRE><FONT SIZE=+1>void Projection(void)
{
&nbsp; int i;

&nbsp; for(i=0;i&lt;Nb_points;i++)
&nbsp; {
&nbsp;&nbsp;&nbsp; Point2D[i].x=(Point3D[i].x&lt;&lt;8)/(Point3D[i].z+Zoff)+Xoff;
&nbsp;&nbsp;&nbsp; Point2D[i].y=(Point3D[i].y&lt;&lt;8)/(Point3D[i].z+Zoff)+Yoff;
&nbsp; }
}</FONT></PRE>
<FONT SIZE=+1>Comme vous le voyez, rien de bien compliqu&eacute;, surtout
si vous avez compris les justifications math&eacute;matiques.</FONT>

<P><FONT SIZE=+1>Il ne nous reste plus qu'&agrave; afficher le tout &agrave;
l'&eacute;cran, sinon &ccedil;a risque de ne pas donner grand chose :o)</FONT>
<PRE><FONT SIZE=+1>void Afficher(int couleur)
{
&nbsp; int i;

&nbsp; /* On efface le contenu de l'ecran virtuel */
&nbsp; ClearBuffer();

&nbsp; /* On dessine dedans */
&nbsp; for (i=0;i&lt;8;i++)
&nbsp;&nbsp;&nbsp; PutPixel(Point2D[i].x,Point2D[i].y,couleur);

&nbsp; /* On affiche le tout a l'ecran, en synchonisant */
&nbsp; WaitVbl();
&nbsp; ShowBuffer();
}</FONT></PRE>
<FONT SIZE=+1>En fait, on ne fait qu'afficher tous les sommets du cube.
&Eacute;tant donn&eacute; qu'on utilise un &eacute;cran virtuel, il faut
effacer son contenu avant de commencer &agrave; dessiner dedans. Ensuite,
on dessine chaque sommet dans le buffer, et on affiche le tout. On attend
cependant le retour du faisceau vertical qui balaie l'&eacute;cran, afin
d'&eacute;viter tout effet de "flic".</FONT>

<P><FONT SIZE=+1>Enfin il ne reste plus qu'&agrave; g&eacute;rer cette
animation. Nous allons tout simplement faire tourner notre cube autour
du centre de l'&eacute;cran. Ce n'est certes pas tr&egrave;s extraordinaire,
mais c'est tr&egrave;s simple &agrave; faire :</FONT>
<PRE><FONT SIZE=+1>&nbsp; /* Animation de note cube jusqu'a pression d'une touche */
&nbsp; while(!kbhit())
&nbsp; {
&nbsp;&nbsp;&nbsp; Rotation(xa,ya,za);
&nbsp;&nbsp;&nbsp; Projection();
&nbsp;&nbsp;&nbsp; Afficher(100);
&nbsp;&nbsp;&nbsp; xa=(xa+1)%360;
&nbsp;&nbsp;&nbsp; ya=(ya+3)%360;
&nbsp;&nbsp;&nbsp; za=(za+1)%360;
&nbsp; }</FONT></PRE>

<CENTER><IMG SRC="cube2.gif" HEIGHT=200 WIDTH=320></CENTER>

<CENTER><I><FONT SIZE=+1>Les sommets du cube en pleine animation</FONT></I></CENTER>


<P><FONT SIZE=+1>Et voil&agrave; !Nous venons de faire notre premi&egrave;re
animation 3D. Vous retrouverez les sources et l'ex&eacute;cutable dans
<A HREF="cube2.zip">cube2.zip</A>. Pour compiler chez vous, vous pouvez
faire un Makefile, ou encore taper simplement :</FONT>
<CENTER><PRE><B><FONT SIZE=+1>wcl386 cube2.c graphics.c</FONT></B></PRE></CENTER>
<B><U><FONT SIZE=+2>3/ Un algorithme de trac&eacute; de ligne</FONT></U></B>

<P><FONT SIZE=+1>Bien que cela ne soit pas propre &agrave; la synth&egrave;se
d'image tridimensionnelles, il est tout de m&ecirc;me important de savoir
comment tracer une droite sur un &eacute;cran, surtout lorsqu'on veut afficher
un objet en fil de fer. Pour cela, il existe de nombreux algorithmes bien
&eacute;prouv&eacute;s. Le plus c&eacute;l&egrave;bre est celui de Bresenham,
et c'est aussi le meilleur. Vous trouverez cet algorithme sur de nombreux
sites et dans beaucoup d'ouvrages d&eacute;di&eacute;s &agrave; la synth&egrave;se
d'image. Il s'agit d'une m&eacute;thode incr&eacute;mentale</FONT>

<P><FONT SIZE=+1>Le but d'un tel algorithme est d'approcher le segment
r&eacute;el par un ensemble de points allum&eacute;s. Tout reste &agrave;
savoir quels pixels allumer.</FONT>

<P><FONT SIZE=+1>Si (x1,y1) sont les coordonn&eacute;es du d&eacute;but
du segment &agrave; afficher et (x2,y2) ses coordonn&eacute;es de fin,
on va poser :</FONT>
<CENTER><FONT SIZE=+1><B>Dx = | x2 - x1 |&nbsp;&nbsp;&nbsp;</B> et<B>&nbsp;&nbsp;
Dy = | y2 - y1 |</B></FONT></CENTER>


<P><FONT SIZE=+1>Pour le moment, supposons que Dy &lt; Dx et que x1&lt;x2.</FONT>

<P><FONT SIZE=+1>La pente du segment &agrave; afficher est donn&eacute;e
par Dy/Dx. La m&eacute;thode utilis&eacute;e consiste &agrave; allumer
des points dans une seule direction, ici la direction x, et n'allumer de
points dans la direction y que si l'erreur entre la pente obtenue et la
pente id&eacute;ale d&eacute;passe un certain seuil. Ainsi, si (x,y) sont
les coordonn&eacute;es du point courant (en cours d'affichage), on aura
en arithm&eacute;tique r&eacute;elle :</FONT>
<PRE><FONT SIZE=+1>pente = Dy/Dx
y = y1
pour x variant de x1 &agrave; x2
{
&nbsp;&nbsp; afficher(x,arrondi(y))
&nbsp;&nbsp; y = y + a
}</FONT></PRE>

<CENTER><IMG SRC="ligne.gif" HEIGHT=150 WIDTH=250></CENTER>


<P><FONT SIZE=+1>On voit que l'on a y = y1 + (x-x1)*(Dy/Dx).</FONT>
<BR><FONT SIZE=+1>Comme on allume les points dans la direction x, on aura
x<SUB>i+1</SUB> = x<SUB>i </SUB>+ 1</FONT>
<BR><FONT SIZE=+1>ce qui donnera yi<SUB>+1</SUB> = y<SUB>i</SUB> + (Dy/Dx)</FONT>
<BR><FONT SIZE=+1>ce qui fait que l'erreur commise si l'on allume un point
dans la direction x est de Dy/Dx</FONT>

<P><FONT SIZE=+1>L'erreur est cumul&eacute;e dans une variable. A chaque
fois on l'incr&eacute;mente de Dy/Dx et l'on commence &agrave; allumer
des points dans l'autre direction d&egrave;s que l'erreur d&eacute;passe
la valeur 1. Pour &eacute;viter d'avoir des r&eacute;els, on utilisera
Dy comme pente au lieu de Dy/Dx (on a multipli&eacute; par Dx) et au lieu
de tester avec la valeur 1, le test se fera avec Dx (1*Dx).</FONT>

<P><FONT SIZE=+1>Voil&agrave; la fonction C qui tient compte de tous les
cas de figures possibles :</FONT>
<PRE><FONT SIZE=+1>void Line(int x1,int y1, int x2,int y2, int couleur)
{
&nbsp; int x,y;
&nbsp; int Dx,Dy;
&nbsp; int xincr,yincr;
&nbsp; int erreur;
&nbsp; int i;

&nbsp; /* On initialise nos variables */
&nbsp; Dx = abs(x2-x1);
&nbsp; Dy = abs(y2-y1);

&nbsp; if(x1&lt;x2)
&nbsp;&nbsp;&nbsp; xincr = 1;
&nbsp; else
&nbsp;&nbsp;&nbsp; xincr = -1;

&nbsp; if(y1&lt;y2)
&nbsp;&nbsp;&nbsp; yincr = 1;
&nbsp; else
&nbsp;&nbsp;&nbsp; yincr = -1;

&nbsp; /* Trace de ligne */
&nbsp; x = x1;
&nbsp; y = y1;
&nbsp; if(Dx>Dy)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erreur = Dx/2;&nbsp;&nbsp;&nbsp;&nbsp; /* c'est plus esthetique comme ca */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;Dx;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += xincr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erreur += Dy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(erreur>Dx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erreur -= Dx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += yincr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PutPixel(x,y,couleur);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp; else
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erreur = Dy/2;&nbsp;&nbsp;&nbsp;&nbsp; /* c'est plus esthetique comme ca */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;Dy;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += yincr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erreur += Dx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(erreur>Dy)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; erreur -= Dy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += xincr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PutPixel(x,y,couleur);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</FONT></PRE>
<B><U><FONT SIZE=+2>4/ Repr&eacute;sentation fili&egrave;re (fil de fer)</FONT></U></B>

<P><FONT SIZE=+1>A pr&eacute;sent nous pouvons afficher notre cube en fil
de fer, sans tenir compte pour le moment des faces cach&eacute;es (<A HREF="cube3.zip">cube3.zip</A>).
Pour cela, il suffit d'afficher chaque ar&ecirc;te de chacune des faces.
On s'aper&ccedil;oit donc que certaines ar&ecirc;tes sont affich&eacute;es
plusieurs fois, ce qui est inutile. Pour rem&eacute;dier &agrave; ce probl&egrave;me,
il faut en principe ajouter des informations suppl&eacute;mentaires &agrave;
nos facettes, pour dire quelles sont les ar&ecirc;tes &agrave; afficher.
Faire ce travail &agrave; la main est en g&eacute;n&eacute;ral tr&egrave;s
laborieux, aussi il est bon d'utiliser des objets provenants d'un modeleur.
Pour l'instant, notre cube est assez simple pour faire ce travail manuellement.</FONT>
<PRE><FONT SIZE=+1>void FilDeFer(int couleur)
{
&nbsp;/* On affiche la face avant */
&nbsp;ligne(0,1,couleur); ligne(1,2,couleur);
&nbsp;ligne(2,3,couleur); ligne(3,0,couleur);

&nbsp;/* Puis la face arriere */
&nbsp;ligne(4,5,couleur); ligne(5,6,couleur);
&nbsp;ligne(6,7,couleur); ligne(7,4,couleur);

&nbsp;/* Et enfin les ar&ecirc;tes restantes */
&nbsp;ligne(0,5,couleur);
&nbsp;ligne(1,4,couleur);
&nbsp;ligne(2,7,couleur);
&nbsp;ligne(3,6,couleur);
}</FONT></PRE>
<FONT SIZE=+1>La fonction ligne est l&agrave; pour simplifier le code et
le rendre plus lisible :</FONT>
<PRE><FONT SIZE=+1>void ligne(int a, int b, int couleur)
{
&nbsp; Line(Point2D[a].x,Point2D[a].y,Point2D[b].x,Point2D[b].y,couleur);
}</FONT></PRE>

<CENTER><IMG SRC="cube3.gif" HEIGHT=200 WIDTH=320></CENTER>

<CENTER><I><FONT SIZE=+1>Le cube en fil de fer</FONT></I></CENTER>


<P><FONT SIZE=+1>Les sources compl&egrave;tes et l'ex&eacute;cutables sont
disponibles dans <A HREF="cube3.zip">cube3.zip</A>.</FONT>

<P><B><U><FONT SIZE=+2>5/ Charger des objets de 3D Studio</FONT></U></B>

<P><FONT SIZE=+1>Les cubes, c'est vrai que c'est id&eacute;al pour d&eacute;buter,
mais &ccedil;a devient vite lassant. Je vais donc vous proposer une fonction
(<A HREF="objet.zip">objet.zip</A>) qui va vous permettre de manipuler
dans vos programmes des objets provenant d'un logiciel bien connu, le modeleur
de 3D Studio. Nous allons en particulier nous int&eacute;resser au format
.ASC, qui est le format ascii de 3DS. Ce format est en effet tr&egrave;s
simple &agrave; g&eacute;rer, en plus des nombreux avantages qu'il peut
apporter.</FONT>

<P><FONT SIZE=+1>Je ne vais pas vous d&eacute;crire en d&eacute;tail le
format en question, puisque je fournit les sources n&eacute;cessaires pour
charger les objets. De plus, les fichiers sauv&eacute;s &agrave; ce format
sont parfaitement lisibles, et vous n'aurez en principe aucun mal &agrave;
comprendre le format et &agrave; le g&eacute;rer vous-m&ecirc;me.</FONT>

<P><FONT SIZE=+1>Rapidement, les objets sont form&eacute;s uniquement de
facettes triangulaires, et un fichier peut contenir plusieurs objets. Apr&egrave;s
la liste des points et de leur coordonn&eacute;es X,Y et Z (&eacute;ventuellement
U et V pour les textures) on trouve la liste des facettes. Voici un exemple
de "loader" de fichier .ASC :</FONT>
<PRE><FONT SIZE=+1>/************************************************************************/
/* ChargerASC() : charge en memoire un objet au format .asc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (format ascii de 3DS)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */
/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; La memoire n'est pas allouee dynamiquement dans un&nbsp;&nbsp;&nbsp; */
/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soucis de lisibilite (programme a but pedagogique&nbsp;&nbsp;&nbsp;&nbsp; */
/************************************************************************/

void ChargerASC(char *nom)
{
&nbsp; FILE&nbsp; *fichier;
&nbsp; char&nbsp; chaine[200];
&nbsp; char&nbsp; *fin;
&nbsp; int&nbsp;&nbsp; i,j;
&nbsp; char&nbsp; temp[50];
&nbsp; float x,y,z;
&nbsp; int&nbsp;&nbsp; a,b,c;

&nbsp; int decalage=0;

&nbsp; if ((fichier = fopen(nom,"rt"))==NULL)
&nbsp; {
&nbsp;&nbsp;&nbsp; perror("Impossible d'ouvrir le fichier en lecture");
&nbsp;&nbsp;&nbsp; exit(-2);
&nbsp; }

&nbsp; do
&nbsp; {
&nbsp;&nbsp;&nbsp; // On lit le fichier contenant les informations sur l'objet
&nbsp;&nbsp;&nbsp; fin=fgets(chaine,100,fichier);
&nbsp;&nbsp;&nbsp; if (!strncmp(chaine,"Vertex",6))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (strncmp(chaine,"Vertex list",11))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Lecture des coordonn‚es d'un point
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]!='X') i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i+=2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]==' ') i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sscanf(chaine+i,"%f",&amp;x);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]!='Y') i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i+=2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]==' ') i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sscanf(chaine+i,"%f",&amp;y);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]!='Z') i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i+=2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]==' ') i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sscanf(chaine+i,"%f",&amp;z);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sommet[Nb_points].x=x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sommet[Nb_points].y=y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sommet[Nb_points].z=z;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nb_points++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!strncmp(chaine,"Face",4))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (strncmp(chaine,"Face list",9))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Lecture d'une facette
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=j=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]!='A') i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i+=2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[j]!=' ') j++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(temp,chaine+i,j-i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[j-i]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Facette[Nb_faces].a=atoi(temp)+decalage;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]!='B') i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i+=2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[j]!=' ') j++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(temp,chaine+i,j-i);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[j-i]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Facette[Nb_faces].b=atoi(temp)+decalage;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]!='C') i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i+=2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j=i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[j]!=' ') j++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(temp,chaine+i,j-i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[j-i]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Facette[Nb_faces].c=atoi(temp)+decalage;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Lecture des aretes visibles
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(chaine[i]!='A') i++;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(temp,chaine+i+3,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[j-i]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Facette[Nb_faces].ab=atoi(temp);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(temp,chaine+i+8,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[j-i]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Facette[Nb_faces].bc=atoi(temp);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(temp,chaine+i+13,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp[j-i]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Facette[Nb_faces].ac=atoi(temp);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nb_faces++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!strncmp(chaine,"Named object",12))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decalage=Nb_points;
&nbsp;&nbsp;&nbsp; }
&nbsp; } while(fin!=NULL);


&nbsp; fclose(fichier);
}</FONT></PRE>
<FONT SIZE=+1>Bien entendu, vous pouvez retrouver un exemple de programme
utilisant cette fonction dans <A HREF="objet.zip">objet.zip</A>. Pour lancer
l'executable, vous pouvez taper par exemple :</FONT>
<CENTER><B><FONT SIZE=+1>objet duck.asc</FONT></B></CENTER>

<CENTER><IMG SRC="objet1.gif" HEIGHT=200 WIDTH=320></CENTER>

<CENTER><I><FONT SIZE=+1>Un petit canard en pleine rotation</FONT></I></CENTER>


<P><FONT SIZE=+1>Le fichier <I>duck.asc </I>est un exemple fournit avec
l'ex&eacute;cutable : vous pourrez ainsi faire tourner vous-m&ecirc;me
ce fameux petit canard si bien connu.</FONT>

<P><FONT SIZE=+1>Le programme charge en m&eacute;moire les coordonn&eacute;es
de chacun des sommets, et affiche ensuite toutes les ar&ecirc;tes de l'objet.
Ici, nous tenons compte du fait qu'une ar&ecirc;te est visible ou non,
puisque cette information est pr&eacute;sente dans le format .ASC.</FONT>

<P><FONT SIZE=+1>Par la suite, nous utiliserons ce type d'objets pour les
programmes d'application.</FONT>

<P>
<HR WIDTH="100%">

<P><FONT SIZE=+1><A HREF="Plan3D.html">[Sommaire]</A> <A HREF="chap3.html">[Pr&eacute;c&eacute;dent]</A>
<A HREF="chap5.html">[Suivant]</A> <A HREF="../accueil.html" TARGET="Contenu">[Home
Page]</A></FONT>

<P><FONT SIZE=+1>Page r&eacute;alis&eacute;e par <A HREF="../cv.html" TARGET="Contenu">Christophe
Heulin.</A></FONT>
<BR><FONT SIZE=+1>Renseignements, critiques, informations : <A HREF="mailto:heulin@multimania.com">heulin@multimania.com</A></FONT>
</BODY>
</HTML>
